/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/typeit/dist/index.es.js":
/*!**********************************************!*\
  !*** ./node_modules/typeit/dist/index.es.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TypeIt)\n/* harmony export */ });\n// TypeIt by Alex MacArthur - https://typeitjs.com\nconst isArray = (thing) => Array.isArray(thing);\nconst asArray = (value) => {\n  return isArray(value) ? value : [value];\n};\nlet Queue = function(initialItems) {\n  let add = function(steps) {\n    asArray(steps).forEach((step) => {\n      return _q.set(Symbol(step.char?.innerText), buildQueueItem({ ...step }));\n    });\n    return this;\n  };\n  let getTypeable = () => rawValues().filter((value) => value.typeable);\n  let set = function(index, item) {\n    let keys = [..._q.keys()];\n    _q.set(keys[index], buildQueueItem(item));\n  };\n  let buildQueueItem = (queueItem) => {\n    queueItem.shouldPauseCursor = function() {\n      return Boolean(this.typeable || this.cursorable || this.deletable);\n    };\n    return queueItem;\n  };\n  let reset = function() {\n    _q.forEach((item) => delete item.done);\n  };\n  let wipe = function() {\n    _q = /* @__PURE__ */ new Map();\n    add(initialItems);\n  };\n  let getQueue = () => _q;\n  let rawValues = () => Array.from(_q.values());\n  let destroy = (key) => _q.delete(key);\n  let getItems = (all = false) => all ? rawValues() : rawValues().filter((i) => !i.done);\n  let done = (key, shouldDestroy = false) => shouldDestroy ? _q.delete(key) : _q.get(key).done = true;\n  let _q = /* @__PURE__ */ new Map();\n  add(initialItems);\n  return {\n    add,\n    set,\n    wipe,\n    reset,\n    destroy,\n    done,\n    getItems,\n    getQueue,\n    getTypeable\n  };\n};\nconst toArray = (val) => Array.from(val);\nconst createTextNode = (content) => document.createTextNode(content);\nlet expandTextNodes = (element) => {\n  [...element.childNodes].forEach((child) => {\n    if (child.nodeValue) {\n      [...child.nodeValue].forEach((c) => {\n        child.parentNode.insertBefore(createTextNode(c), child);\n      });\n      child.remove();\n      return;\n    }\n    expandTextNodes(child);\n  });\n  return element;\n};\nconst getParsedBody = (content) => {\n  let doc = document.implementation.createHTMLDocument();\n  doc.body.innerHTML = content;\n  return expandTextNodes(doc.body);\n};\nconst DATA_ATTRIBUTE = \"data-typeit-id\";\nconst CURSOR_CLASS = \"ti-cursor\";\nconst END = \"END\";\nconst DEFAULT_STATUSES = {\n  started: false,\n  completed: false,\n  frozen: false,\n  destroyed: false\n};\nconst DEFAULT_OPTIONS = {\n  breakLines: true,\n  cursor: {\n    autoPause: true,\n    autoPauseDelay: 500,\n    animation: {\n      frames: [0, 0, 1].map((n) => {\n        return { opacity: n };\n      }),\n      options: {\n        iterations: Infinity,\n        easing: \"steps(2, start)\",\n        fill: \"forwards\"\n      }\n    }\n  },\n  cursorChar: \"|\",\n  cursorSpeed: 1e3,\n  deleteSpeed: null,\n  html: true,\n  lifeLike: true,\n  loop: false,\n  loopDelay: 750,\n  nextStringDelay: 750,\n  speed: 100,\n  startDelay: 250,\n  startDelete: false,\n  strings: [],\n  waitUntilVisible: false,\n  beforeString: () => {\n  },\n  afterString: () => {\n  },\n  beforeStep: () => {\n  },\n  afterStep: () => {\n  },\n  afterComplete: () => {\n  }\n};\nconst PLACEHOLDER_CSS = `[${DATA_ATTRIBUTE}]:before {content: '.'; display: inline-block; width: 0; visibility: hidden;}`;\nfunction walkElementNodes(element, shouldReverse = false, shouldIncludeCursor = false) {\n  let cursor = element.querySelector(`.${CURSOR_CLASS}`);\n  let walker = document.createTreeWalker(element, NodeFilter.SHOW_ALL, {\n    acceptNode: (node) => {\n      if (cursor && shouldIncludeCursor) {\n        if (node.classList?.contains(CURSOR_CLASS)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n        if (cursor.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n      return node.classList?.contains(CURSOR_CLASS) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;\n    }\n  });\n  let nextNode;\n  let nodes = [];\n  while (nextNode = walker.nextNode()) {\n    if (!nextNode.originalParent) {\n      nextNode.originalParent = nextNode.parentNode;\n    }\n    nodes.push(nextNode);\n  }\n  return shouldReverse ? nodes.reverse() : nodes;\n}\nfunction chunkStringAsHtml(string) {\n  return walkElementNodes(getParsedBody(string));\n}\nfunction maybeChunkStringAsHtml(str, asHtml = true) {\n  return asHtml ? chunkStringAsHtml(str) : toArray(str).map(createTextNode);\n}\nconst createElement = (el) => document.createElement(el);\nconst appendStyleBlock = (styles, id = \"\") => {\n  let styleBlock = createElement(\"style\");\n  styleBlock.id = id;\n  styleBlock.appendChild(createTextNode(styles));\n  document.head.appendChild(styleBlock);\n};\nconst calculateDelay = (delayArg) => {\n  if (!isArray(delayArg)) {\n    delayArg = [delayArg / 2, delayArg / 2];\n  }\n  return delayArg;\n};\nconst randomInRange = (value, range2) => {\n  return Math.abs(\n    Math.random() * (value + range2 - (value - range2)) + (value - range2)\n  );\n};\nlet range = (val) => val / 2;\nfunction calculatePace(options) {\n  let { speed, deleteSpeed, lifeLike } = options;\n  deleteSpeed = deleteSpeed !== null ? deleteSpeed : speed / 3;\n  return lifeLike ? [\n    randomInRange(speed, range(speed)),\n    randomInRange(deleteSpeed, range(deleteSpeed))\n  ] : [speed, deleteSpeed];\n}\nconst destroyTimeouts = (timeouts) => {\n  timeouts.forEach(clearTimeout);\n  return [];\n};\nconst generateHash = () => Math.random().toString().substring(2, 9);\nconst isInput = (el) => \"value\" in el;\nlet getAllChars = (element) => {\n  if (isInput(element)) {\n    return toArray(element.value);\n  }\n  return walkElementNodes(element, true).filter(\n    (c) => !(c.childNodes.length > 0)\n  );\n};\nconst fireWhenVisible = (element, func) => {\n  let observer = new IntersectionObserver(\n    (entries, observer2) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          func();\n          observer2.unobserve(element);\n        }\n      });\n    },\n    { threshold: 1 }\n  );\n  observer.observe(element);\n};\nlet handleFunctionalArg = (arg) => {\n  return typeof arg === \"function\" ? arg() : arg;\n};\nconst isNumber = (value) => Number.isInteger(value);\nlet select = (selector, element = document, all = false) => {\n  return element[`querySelector${all ? \"All\" : \"\"}`](selector);\n};\nlet isBodyElement = (node) => /body/i.test(node?.tagName);\nlet insertIntoElement = (originalTarget, character) => {\n  if (isInput(originalTarget)) {\n    originalTarget.value = `${originalTarget.value}${character.textContent}`;\n    return;\n  }\n  character.innerHTML = \"\";\n  let target = isBodyElement(character.originalParent) ? originalTarget : character.originalParent || originalTarget;\n  target.insertBefore(\n    character,\n    select(\".\" + CURSOR_CLASS, target) || null\n  );\n};\nlet updateCursorPosition = (steps, cursorPosition, printedCharacters) => {\n  return Math.min(\n    Math.max(cursorPosition + steps, 0),\n    printedCharacters.length\n  );\n};\nconst merge = (originalObj, newObj) => Object.assign({}, originalObj, newObj);\nconst removeNode = (node, rootElement) => {\n  if (!node)\n    return;\n  let nodeParent = node.parentNode;\n  let nodeToRemove = nodeParent.childNodes.length > 1 || nodeParent.isSameNode(rootElement) ? node : nodeParent;\n  nodeToRemove.remove();\n};\nconst repositionCursor = (element, allChars, newCursorPosition) => {\n  let nodeToInsertBefore = allChars[newCursorPosition - 1];\n  let cursor = select(`.${CURSOR_CLASS}`, element);\n  element = nodeToInsertBefore?.parentNode || element;\n  element.insertBefore(cursor, nodeToInsertBefore || null);\n};\nfunction selectorToElement(thing) {\n  return typeof thing === \"string\" ? select(thing) : thing;\n}\nconst isNonVoidElement = (el) => /<(.+)>(.*?)<\\/(.+)>/.test(el.outerHTML);\nlet wait = (callback, delay, timeouts) => {\n  return new Promise((resolve) => {\n    let cb = async () => {\n      await callback();\n      resolve();\n    };\n    timeouts.push(setTimeout(cb, delay || 0));\n  });\n};\nlet cursorFontStyles = {\n  \"font-family\": \"\",\n  \"font-weight\": \"\",\n  \"font-size\": \"\",\n  \"font-style\": \"\",\n  \"line-height\": \"\",\n  color: \"\",\n  transform: \"translateX(-.125em)\"\n};\nlet setCursorStyles = (id, element) => {\n  let rootSelector = `[${DATA_ATTRIBUTE}='${id}']`;\n  let cursorSelector = `${rootSelector} .${CURSOR_CLASS}`;\n  let computedStyles = getComputedStyle(element);\n  let customProperties = Object.entries(cursorFontStyles).reduce(\n    (accumulator, [item, value]) => {\n      return `${accumulator} ${item}: var(--ti-cursor-${item}, ${value || computedStyles[item]});`;\n    },\n    \"\"\n  );\n  appendStyleBlock(\n    `${cursorSelector} { display: inline-block; width: 0; ${customProperties} }`,\n    id\n  );\n};\nconst duplicate = (value, times) => new Array(times).fill(value);\nconst countStepsToSelector = ({\n  queueItems,\n  selector,\n  cursorPosition,\n  to\n}) => {\n  if (isNumber(selector)) {\n    return selector * -1;\n  }\n  let isMovingToEnd = new RegExp(END, \"i\").test(to);\n  let selectorIndex = selector ? [...queueItems].reverse().findIndex(({ char }) => {\n    let parentElement = char.parentElement;\n    let parentMatches = parentElement.matches(selector);\n    if (isMovingToEnd && parentMatches) {\n      return true;\n    }\n    return parentMatches && parentElement.firstChild.isSameNode(char);\n  }) : -1;\n  if (selectorIndex < 0) {\n    selectorIndex = isMovingToEnd ? 0 : queueItems.length - 1;\n  }\n  let offset = isMovingToEnd ? 0 : 1;\n  return selectorIndex - cursorPosition + offset;\n};\nlet beforePaint = (cb) => {\n  return new Promise((resolve) => {\n    requestAnimationFrame(async () => {\n      resolve(await cb());\n    });\n  });\n};\nlet getAnimationFromElement = (element) => {\n  return element?.getAnimations().find((animation) => {\n    return animation.id === element.dataset.tiAnimationId;\n  });\n};\nlet setCursorAnimation = ({\n  cursor,\n  frames,\n  options\n}) => {\n  let animation = cursor.animate(frames, options);\n  animation.pause();\n  animation.id = cursor.dataset.tiAnimationId;\n  beforePaint(() => {\n    beforePaint(() => {\n      animation.play();\n    });\n  });\n  return animation;\n};\nlet rebuildCursorAnimation = ({\n  cursor,\n  options,\n  cursorOptions\n}) => {\n  if (!cursor || !cursorOptions)\n    return;\n  let animation = getAnimationFromElement(cursor);\n  let oldCurrentTime;\n  if (animation) {\n    options.delay = animation.effect.getComputedTiming().delay;\n    oldCurrentTime = animation.currentTime;\n    animation.cancel();\n  }\n  let newAnimation = setCursorAnimation({\n    cursor,\n    frames: cursorOptions.animation.frames,\n    options\n  });\n  if (oldCurrentTime) {\n    newAnimation.currentTime = oldCurrentTime;\n  }\n  return newAnimation;\n};\nlet execute = (queueItem) => queueItem.func?.call(null);\nlet fireItem = async ({\n  index,\n  queueItems,\n  wait: wait2,\n  cursor,\n  cursorOptions\n}) => {\n  let queueItem = queueItems[index][1];\n  let instantQueue = [];\n  let tempIndex = index;\n  let futureItem = queueItem;\n  let shouldBeGrouped = () => futureItem && !futureItem.delay;\n  let shouldPauseCursor = queueItem.shouldPauseCursor() && cursorOptions.autoPause;\n  while (shouldBeGrouped()) {\n    instantQueue.push(futureItem);\n    shouldBeGrouped() && tempIndex++;\n    futureItem = queueItems[tempIndex] ? queueItems[tempIndex][1] : null;\n  }\n  if (instantQueue.length) {\n    await beforePaint(async () => {\n      for (let q of instantQueue) {\n        await execute(q);\n      }\n    });\n    return tempIndex - 1;\n  }\n  let animation = getAnimationFromElement(cursor);\n  let options;\n  if (animation) {\n    options = {\n      ...animation.effect.getComputedTiming(),\n      delay: shouldPauseCursor ? cursorOptions.autoPauseDelay : 0\n    };\n  }\n  await wait2(async () => {\n    if (animation && shouldPauseCursor) {\n      animation.cancel();\n    }\n    await beforePaint(() => {\n      execute(queueItem);\n    });\n  }, queueItem.delay);\n  await rebuildCursorAnimation({\n    cursor,\n    options,\n    cursorOptions\n  });\n  return index;\n};\nlet processCursorOptions = (cursorOptions) => {\n  if (typeof cursorOptions === \"object\") {\n    let newOptions = {};\n    let { frames: defaultFrames, options: defaultOptions } = DEFAULT_OPTIONS.cursor.animation;\n    newOptions.animation = cursorOptions.animation || {};\n    newOptions.animation.frames = cursorOptions.animation?.frames || defaultFrames;\n    newOptions.animation.options = merge(\n      defaultOptions,\n      cursorOptions.animation?.options || {}\n    );\n    newOptions.autoPause = cursorOptions.autoPause ?? DEFAULT_OPTIONS.cursor.autoPause;\n    newOptions.autoPauseDelay = cursorOptions.autoPauseDelay || DEFAULT_OPTIONS.cursor.autoPauseDelay;\n    return newOptions;\n  }\n  if (cursorOptions === true) {\n    return DEFAULT_OPTIONS.cursor;\n  }\n  return cursorOptions;\n};\nconst TypeIt = function(element, options = {}) {\n  let _wait = async (callback, delay, silent = false) => {\n    if (_statuses.frozen) {\n      await new Promise((resolve) => {\n        this.unfreeze = () => {\n          _statuses.frozen = false;\n          resolve();\n        };\n      });\n    }\n    silent || await _opts.beforeStep(this);\n    await wait(callback, delay, _timeouts);\n    silent || await _opts.afterStep(this);\n  };\n  let _fireItemWithContext = (index, queueItems) => {\n    return fireItem({\n      index,\n      queueItems,\n      wait: _wait,\n      cursor: _cursor,\n      cursorOptions: _opts.cursor\n    });\n  };\n  let _removeNode = (node) => removeNode(node, _element);\n  let _elementIsInput = () => isInput(_element);\n  let _getPace = (index = 0) => calculatePace(_opts)[index];\n  let _getAllChars = () => getAllChars(_element);\n  let _maybeAppendPause = (opts = {}) => {\n    let delay = opts.delay;\n    delay && _queue.add({ delay });\n  };\n  let _queueAndReturn = (steps, opts) => {\n    _queue.add(steps);\n    _maybeAppendPause(opts);\n    return this;\n  };\n  let _getDerivedCursorPosition = () => _predictedCursorPosition ?? _cursorPosition;\n  let _generateTemporaryOptionQueueItems = (newOptions = {}) => {\n    return [\n      { func: () => _options(newOptions) },\n      { func: () => _options(_opts) }\n    ];\n  };\n  let _addSplitPause = (items) => {\n    let delay = _opts.nextStringDelay;\n    _queue.add([{ delay: delay[0] }, ...items, { delay: delay[1] }]);\n  };\n  let _setUpCursor = () => {\n    if (_elementIsInput()) {\n      return;\n    }\n    let cursor = createElement(\"span\");\n    cursor.className = CURSOR_CLASS;\n    if (!_shouldRenderCursor) {\n      cursor.style.visibility = \"hidden\";\n      return cursor;\n    }\n    cursor.innerHTML = getParsedBody(_opts.cursorChar).innerHTML;\n    return cursor;\n  };\n  let _attachCursor = async () => {\n    !_elementIsInput() && _cursor && _element.appendChild(_cursor);\n    if (_shouldRenderCursor) {\n      setCursorStyles(_id, _element);\n      _cursor.dataset.tiAnimationId = _id;\n      let { animation } = _opts.cursor;\n      let { frames, options: options2 } = animation;\n      setCursorAnimation({\n        frames,\n        cursor: _cursor,\n        options: {\n          duration: _opts.cursorSpeed,\n          ...options2\n        }\n      });\n    }\n  };\n  let _generateQueue = () => {\n    let strings = _opts.strings.filter((string) => !!string);\n    strings.forEach((string, index) => {\n      this.type(string);\n      if (index + 1 === strings.length) {\n        return;\n      }\n      let splitItems = _opts.breakLines ? [{ func: () => _type(createElement(\"BR\")), typeable: true }] : duplicate(\n        {\n          func: _delete,\n          delay: _getPace(1)\n        },\n        _queue.getTypeable().length\n      );\n      _addSplitPause(splitItems);\n    });\n  };\n  let _prepLoop = async (delay) => {\n    let derivedCursorPosition = _getDerivedCursorPosition();\n    derivedCursorPosition && await _move({ value: derivedCursorPosition });\n    let queueItems = _getAllChars().map((c) => {\n      return [\n        Symbol(),\n        {\n          func: _delete,\n          delay: _getPace(1),\n          deletable: true,\n          shouldPauseCursor: () => true\n        }\n      ];\n    });\n    for (let index = 0; index < queueItems.length; index++) {\n      await _fireItemWithContext(index, queueItems);\n    }\n    _queue.reset();\n    _queue.set(0, { delay });\n  };\n  let _maybePrependHardcodedStrings = (strings) => {\n    let existingMarkup = _element.innerHTML;\n    if (!existingMarkup) {\n      return strings;\n    }\n    _element.innerHTML = \"\";\n    if (_opts.startDelete) {\n      _element.innerHTML = existingMarkup;\n      expandTextNodes(_element);\n      _addSplitPause(\n        duplicate(\n          {\n            func: _delete,\n            delay: _getPace(1),\n            deletable: true\n          },\n          _getAllChars().length\n        )\n      );\n      return strings;\n    }\n    let hardCodedStrings = existingMarkup.replace(/<!--(.+?)-->/g, \"\").trim().split(/<br(?:\\s*?)(?:\\/)?>/);\n    return hardCodedStrings.concat(strings);\n  };\n  let _fire = async (remember = true) => {\n    _statuses.started = true;\n    let cleanUp = (qKey) => {\n      _queue.done(qKey, !remember);\n    };\n    try {\n      let queueItems = [..._queue.getQueue()];\n      for (let index = 0; index < queueItems.length; index++) {\n        let [queueKey, queueItem] = queueItems[index];\n        if (queueItem.done)\n          continue;\n        if (!queueItem.deletable || queueItem.deletable && _getAllChars().length) {\n          let newIndex = await _fireItemWithContext(index, queueItems);\n          Array(newIndex - index).fill(index + 1).map((x, y) => x + y).forEach((i) => {\n            let [key] = queueItems[i];\n            cleanUp(key);\n          });\n          index = newIndex;\n        }\n        cleanUp(queueKey);\n      }\n      if (!remember) {\n        return this;\n      }\n      _statuses.completed = true;\n      await _opts.afterComplete(this);\n      if (!_opts.loop) {\n        throw \"\";\n      }\n      let delay = _opts.loopDelay;\n      _wait(async () => {\n        await _prepLoop(delay[0]);\n        _fire();\n      }, delay[1]);\n    } catch (e) {\n    }\n    return this;\n  };\n  let _move = async (step) => {\n    _cursorPosition = updateCursorPosition(\n      step,\n      _cursorPosition,\n      _getAllChars()\n    );\n    repositionCursor(_element, _getAllChars(), _cursorPosition);\n  };\n  let _type = (char) => insertIntoElement(_element, char);\n  let _options = async (opts) => _opts = merge(_opts, opts);\n  let _empty = async () => {\n    if (_elementIsInput()) {\n      _element.value = \"\";\n      return;\n    }\n    _getAllChars().forEach(_removeNode);\n    return;\n  };\n  let _delete = () => {\n    let allChars = _getAllChars();\n    if (!allChars.length)\n      return;\n    if (_elementIsInput()) {\n      _element.value = _element.value.slice(0, -1);\n    } else {\n      _removeNode(allChars[_cursorPosition]);\n    }\n  };\n  this.break = function(actionOpts) {\n    return _queueAndReturn(\n      {\n        func: () => _type(createElement(\"BR\")),\n        typeable: true\n      },\n      actionOpts\n    );\n  };\n  this.delete = function(numCharacters = null, actionOpts = {}) {\n    numCharacters = handleFunctionalArg(numCharacters);\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let num = numCharacters;\n    let { instant, to } = actionOpts;\n    let typeableQueueItems = _queue.getTypeable();\n    let rounds = (() => {\n      if (num === null) {\n        return typeableQueueItems.length;\n      }\n      if (isNumber(num)) {\n        return num;\n      }\n      return countStepsToSelector({\n        queueItems: typeableQueueItems,\n        selector: num,\n        cursorPosition: _getDerivedCursorPosition(),\n        to\n      });\n    })();\n    return _queueAndReturn(\n      [\n        bookEndQueueItems[0],\n        ...duplicate(\n          {\n            func: _delete,\n            delay: instant ? 0 : _getPace(1),\n            deletable: true\n          },\n          rounds\n        ),\n        bookEndQueueItems[1]\n      ],\n      actionOpts\n    );\n  };\n  this.empty = function(actionOpts = {}) {\n    return _queueAndReturn({ func: _empty }, actionOpts);\n  };\n  this.exec = function(func, actionOpts = {}) {\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    return _queueAndReturn(\n      [bookEndQueueItems[0], { func: () => func(this) }, bookEndQueueItems[1]],\n      actionOpts\n    );\n  };\n  this.move = function(movementArg, actionOpts = {}) {\n    movementArg = handleFunctionalArg(movementArg);\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let { instant, to } = actionOpts;\n    let numberOfSteps = countStepsToSelector({\n      queueItems: _queue.getTypeable(),\n      selector: movementArg === null ? \"\" : movementArg,\n      to,\n      cursorPosition: _getDerivedCursorPosition()\n    });\n    let directionalStep = numberOfSteps < 0 ? -1 : 1;\n    _predictedCursorPosition = _getDerivedCursorPosition() + numberOfSteps;\n    return _queueAndReturn(\n      [\n        bookEndQueueItems[0],\n        ...duplicate(\n          {\n            func: () => _move(directionalStep),\n            delay: instant ? 0 : _getPace(),\n            cursorable: true\n          },\n          Math.abs(numberOfSteps)\n        ),\n        bookEndQueueItems[1]\n      ],\n      actionOpts\n    );\n  };\n  this.options = function(opts, actionOpts = {}) {\n    opts = handleFunctionalArg(opts);\n    _options(opts);\n    return _queueAndReturn({}, actionOpts);\n  };\n  this.pause = function(milliseconds, actionOpts = {}) {\n    return _queueAndReturn(\n      { delay: handleFunctionalArg(milliseconds) },\n      actionOpts\n    );\n  };\n  this.type = function(string, actionOpts = {}) {\n    string = handleFunctionalArg(string);\n    let { instant } = actionOpts;\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let chars = maybeChunkStringAsHtml(string, _opts.html);\n    let charsAsQueueItems = chars.map((char) => {\n      return {\n        func: () => _type(char),\n        char,\n        delay: instant || isNonVoidElement(char) ? 0 : _getPace(),\n        typeable: char.nodeType === Node.TEXT_NODE\n      };\n    });\n    let itemsToQueue = [\n      bookEndQueueItems[0],\n      { func: async () => await _opts.beforeString(string, this) },\n      ...charsAsQueueItems,\n      { func: async () => await _opts.afterString(string, this) },\n      bookEndQueueItems[1]\n    ];\n    return _queueAndReturn(itemsToQueue, actionOpts);\n  };\n  this.is = function(key) {\n    return _statuses[key];\n  };\n  this.destroy = function(shouldRemoveCursor = true) {\n    _timeouts = destroyTimeouts(_timeouts);\n    handleFunctionalArg(shouldRemoveCursor) && _cursor && _removeNode(_cursor);\n    _statuses.destroyed = true;\n  };\n  this.freeze = function() {\n    _statuses.frozen = true;\n  };\n  this.unfreeze = () => {\n  };\n  this.reset = function(rebuild) {\n    !this.is(\"destroyed\") && this.destroy();\n    if (rebuild) {\n      _queue.wipe();\n      rebuild(this);\n    } else {\n      _queue.reset();\n    }\n    _cursorPosition = 0;\n    for (let property in _statuses) {\n      _statuses[property] = false;\n    }\n    _element[_elementIsInput() ? \"value\" : \"innerHTML\"] = \"\";\n    return this;\n  };\n  this.go = function() {\n    if (_statuses.started) {\n      return this;\n    }\n    _attachCursor();\n    if (!_opts.waitUntilVisible) {\n      _fire();\n      return this;\n    }\n    fireWhenVisible(_element, _fire.bind(this));\n    return this;\n  };\n  this.flush = function(cb = () => {\n  }) {\n    _attachCursor();\n    _fire(false).then(cb);\n    return this;\n  };\n  this.getQueue = () => _queue;\n  this.getOptions = () => _opts;\n  this.updateOptions = (options2) => _options(options2);\n  this.getElement = () => _element;\n  let _element = selectorToElement(element);\n  let _timeouts = [];\n  let _cursorPosition = 0;\n  let _predictedCursorPosition = null;\n  let _statuses = merge({}, DEFAULT_STATUSES);\n  options.cursor = processCursorOptions(\n    options.cursor ?? DEFAULT_OPTIONS.cursor\n  );\n  let _opts = merge(DEFAULT_OPTIONS, options);\n  _opts = merge(_opts, {\n    html: !_elementIsInput() && _opts.html,\n    nextStringDelay: calculateDelay(_opts.nextStringDelay),\n    loopDelay: calculateDelay(_opts.loopDelay)\n  });\n  let _id = generateHash();\n  let _queue = Queue([{ delay: _opts.startDelay }]);\n  _element.dataset.typeitId = _id;\n  appendStyleBlock(PLACEHOLDER_CSS);\n  let _shouldRenderCursor = !!_opts.cursor && !_elementIsInput();\n  let _cursor = _setUpCursor();\n  _opts.strings = _maybePrependHardcodedStrings(asArray(_opts.strings));\n  if (_opts.strings.length) {\n    _generateQueue();\n  }\n};\n\n\n\n//# sourceURL=webpack://FORKIO/./node_modules/typeit/dist/index.es.js?");

/***/ }),

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utilities_utilsExports_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities/_utilsExports.js */ \"./src/js/utilities/_utilsExports.js\");\n/* harmony import */ var _modules_modulesExports_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/_modulesExports.js */ \"./src/js/modules/_modulesExports.js\");\n/* harmony import */ var _vendors_vendorsExports_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vendors/_vendorsExports.js */ \"./src/js/vendors/_vendorsExports.js\");\n\r\n\r\n\r\n\r\n_utilities_utilsExports_js__WEBPACK_IMPORTED_MODULE_0__.isWebp()\r\n_utilities_utilsExports_js__WEBPACK_IMPORTED_MODULE_0__.scrollAnimation()\r\n_utilities_utilsExports_js__WEBPACK_IMPORTED_MODULE_0__.validateEmail()\r\n\r\n_modules_modulesExports_js__WEBPACK_IMPORTED_MODULE_1__.burger()\r\n_modules_modulesExports_js__WEBPACK_IMPORTED_MODULE_1__.offerItemAnimation()\r\nwindow.addEventListener('load', _modules_modulesExports_js__WEBPACK_IMPORTED_MODULE_1__.windowLoad)\r\n\r\n_vendors_vendorsExports_js__WEBPACK_IMPORTED_MODULE_2__.typingAnimation.go()\r\n\r\n\n\n//# sourceURL=webpack://FORKIO/./src/js/app.js?");

/***/ }),

/***/ "./src/js/modules/_modulesExports.js":
/*!*******************************************!*\
  !*** ./src/js/modules/_modulesExports.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"burger\": () => (/* reexport safe */ _burger_js__WEBPACK_IMPORTED_MODULE_0__.burger),\n/* harmony export */   \"offerItemAnimation\": () => (/* reexport safe */ _offerItemAnimation_js__WEBPACK_IMPORTED_MODULE_1__.offerItemAnimation),\n/* harmony export */   \"windowLoad\": () => (/* reexport safe */ _counter_js__WEBPACK_IMPORTED_MODULE_2__.windowLoad)\n/* harmony export */ });\n/* harmony import */ var _burger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./burger.js */ \"./src/js/modules/burger.js\");\n/* harmony import */ var _offerItemAnimation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./offerItemAnimation.js */ \"./src/js/modules/offerItemAnimation.js\");\n/* harmony import */ var _counter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./counter.js */ \"./src/js/modules/counter.js\");\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://FORKIO/./src/js/modules/_modulesExports.js?");

/***/ }),

/***/ "./src/js/modules/burger.js":
/*!**********************************!*\
  !*** ./src/js/modules/burger.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"burger\": () => (/* binding */ burger)\n/* harmony export */ });\n\r\n\r\nconst burger = () => {\r\n   const navbar = document.querySelector('.navbar')\r\n   const conditionsCloseBurger = (e) => navbar.classList.contains('open') && !e.target.closest('.navbar__list') && !e.target.closest('.burger');\r\n\r\n   document.body.addEventListener('click', e => {\r\n      if (conditionsCloseBurger(e)) {\r\n         navbar.classList.remove('open')\r\n      }\r\n\r\n      if (e.target.closest('.burger')) {\r\n         navbar.classList.toggle('open')\r\n      }\r\n   })\r\n}\r\n\n\n//# sourceURL=webpack://FORKIO/./src/js/modules/burger.js?");

/***/ }),

/***/ "./src/js/modules/counter.js":
/*!***********************************!*\
  !*** ./src/js/modules/counter.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"windowLoad\": () => (/* binding */ windowLoad)\n/* harmony export */ });\n\n\nconst ANIMATION_DURATION = 2000;\n\nconst windowLoad = () => {\n  const digitsCounterInit = (digitsCountersItems) => {\n    let digitsCounters = digitsCountersItems\n      ? digitsCountersItems\n      : document.querySelectorAll(\"[data-digits-coutter]\");\n\n    if (digitsCounters) {\n      digitsCounters.forEach((digitsCounter) => {\n        digitsCountersAnimate(digitsCounter);\n      });\n    }\n  };\n\n  const digitsCountersAnimate = (digitsCounter) => {\n    let startTimestamp = null;\n\n    const startValue = parseInt(digitsCounter.innerHTML);\n    const startPosition = 0;\n\n    const step = (timestamp) => {\n      if (!startTimestamp) {\n        startTimestamp = timestamp;\n      }\n\n      const progress = Math.min(\n        (timestamp - startTimestamp) / ANIMATION_DURATION,\n        1\n      );\n      digitsCounter.innerHTML = Math.floor(\n        progress * (startPosition + startValue)\n      );\n\n      if (progress < 1) {\n        window.requestAnimationFrame(step);\n      }\n    };\n\n    window.requestAnimationFrame(step);\n  };\n\n  let options = {\n    threshold: 0.8,\n  };\n\n  let observer = new IntersectionObserver((entries, observer) => {\n    entries.forEach((entry) => {\n      if (entry.isIntersecting) {\n        const targetElement = entry.target;\n        const digitsCountersItems = targetElement.querySelectorAll(\n          \"[data-digits-coutter]\"\n        );\n\n        if (digitsCountersItems.length) {\n          digitsCounterInit(digitsCountersItems);\n        }\n\n        observer.unobserve(targetElement);\n      }\n    });\n  }, options);\n\n  let sections = document.querySelector(\".revolutionary_editor\");\n  observer.observe(sections);\n};\n\n\n//# sourceURL=webpack://FORKIO/./src/js/modules/counter.js?");

/***/ }),

/***/ "./src/js/modules/offerItemAnimation.js":
/*!**********************************************!*\
  !*** ./src/js/modules/offerItemAnimation.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"offerItemAnimation\": () => (/* binding */ offerItemAnimation)\n/* harmony export */ });\n/* harmony import */ var _utilities_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/constants.js */ \"./src/js/utilities/constants.js\");\n\r\n;\r\n\r\nconst offerItemAnimation = () => {\r\n   const addClassName = () => {\r\n      const pricingCards = document.querySelectorAll('.offer-item')\r\n      const offersContainer = document.querySelector('.pricing__offers')\r\n      const selectCard = Array.from(pricingCards).find(card => card.children[0].textContent === 'agency')\r\n\r\n      selectCard.classList.add('select')\r\n      offersContainer.addEventListener('mouseenter', e => {\r\n         if (window.innerWidth >= _utilities_constants_js__WEBPACK_IMPORTED_MODULE_0__.BREAK_POINT && e.target === offersContainer) {\r\n            selectCard.classList.remove('select')\r\n         }\r\n      })\r\n      offersContainer.addEventListener('mouseleave', e => {\r\n         if (window.innerWidth >= _utilities_constants_js__WEBPACK_IMPORTED_MODULE_0__.BREAK_POINT && e.target === offersContainer) {\r\n            selectCard.classList.add('select')\r\n         }\r\n      })\r\n\r\n      if (window.innerWidth <= _utilities_constants_js__WEBPACK_IMPORTED_MODULE_0__.BREAK_POINT) {\r\n         selectCard.classList.add('select')\r\n      }\r\n   }\r\n   addClassName()\r\n   addEventListener('resize', addClassName)\r\n}\r\n\n\n//# sourceURL=webpack://FORKIO/./src/js/modules/offerItemAnimation.js?");

/***/ }),

/***/ "./src/js/utilities/_utilsExports.js":
/*!*******************************************!*\
  !*** ./src/js/utilities/_utilsExports.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isWebp\": () => (/* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_1__.isWebp),\n/* harmony export */   \"scrollAnimation\": () => (/* reexport safe */ _scrollAnimation_js__WEBPACK_IMPORTED_MODULE_0__.scrollAnimation),\n/* harmony export */   \"validateEmail\": () => (/* reexport safe */ _validateEmail_js__WEBPACK_IMPORTED_MODULE_2__.validateEmail)\n/* harmony export */ });\n/* harmony import */ var _scrollAnimation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scrollAnimation.js */ \"./src/js/utilities/scrollAnimation.js\");\n/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functions.js */ \"./src/js/utilities/functions.js\");\n/* harmony import */ var _validateEmail_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./validateEmail.js */ \"./src/js/utilities/validateEmail.js\");\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://FORKIO/./src/js/utilities/_utilsExports.js?");

/***/ }),

/***/ "./src/js/utilities/constants.js":
/*!***************************************!*\
  !*** ./src/js/utilities/constants.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ANIMATION_START_POSITION\": () => (/* binding */ ANIMATION_START_POSITION),\n/* harmony export */   \"BREAK_POINT\": () => (/* binding */ BREAK_POINT),\n/* harmony export */   \"EMAIL_REGEXP\": () => (/* binding */ EMAIL_REGEXP),\n/* harmony export */   \"WEBP_SRC\": () => (/* binding */ WEBP_SRC)\n/* harmony export */ });\n// path to test image for isWebP\r\nconst WEBP_SRC = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA'\r\n\r\n// for validateEmail.js\r\nconst EMAIL_REGEXP =\r\n   /[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/\r\n\r\n// point on the item from which the animation will start (scrollAnimation.js)\r\nconst ANIMATION_START_POSITION = 2.5\r\n\r\n// screen width value for offerItemAnimation.js\r\nconst BREAK_POINT = 1255\r\n\n\n//# sourceURL=webpack://FORKIO/./src/js/utilities/constants.js?");

/***/ }),

/***/ "./src/js/utilities/functions.js":
/*!***************************************!*\
  !*** ./src/js/utilities/functions.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isWebp\": () => (/* binding */ isWebp)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./src/js/utilities/constants.js\");\n\r\n\r\nconst isWebp = () => {\r\n   const testWebP = callback => {\r\n      const webP = new Image()\r\n\r\n      webP.onload = webP.onerror = () => {\r\n         callback(webP.height === 2)\r\n      }\r\n      webP.src = _constants_js__WEBPACK_IMPORTED_MODULE_0__.WEBP_SRC\r\n   }\r\n\r\n   testWebP(support => {\r\n      const className = support === true ? 'webp' : 'no-webp'\r\n      document.documentElement.classList.add(className)\r\n   })\r\n}\r\n\n\n//# sourceURL=webpack://FORKIO/./src/js/utilities/functions.js?");

/***/ }),

/***/ "./src/js/utilities/scrollAnimation.js":
/*!*********************************************!*\
  !*** ./src/js/utilities/scrollAnimation.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"scrollAnimation\": () => (/* binding */ scrollAnimation)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./src/js/utilities/constants.js\");\n\r\n;\r\n\r\nconst animItems = document.querySelectorAll('.anim-item')\r\n\r\nconst offset = el => {\r\n   const rect = el.getBoundingClientRect()\r\n   const scrollTop = window.pageYOffset || document.documentElement.scrollTop\r\n   const itemOffset = rect.top + scrollTop\r\n\r\n   return itemOffset\r\n}\r\n\r\nconst scrollAnimation = () => {\r\n   animItems.forEach(item => {\r\n      const itemHeight = item.offsetHeight\r\n      const itemOffset = offset(item)\r\n      const screenHeight = window.innerHeight\r\n\r\n      let itemPoint = screenHeight - itemHeight / _constants_js__WEBPACK_IMPORTED_MODULE_0__.ANIMATION_START_POSITION\r\n      let isItemVisible = scrollY > itemOffset - itemPoint\r\n\r\n      if (isItemVisible) {\r\n         item.classList.add('show-up')\r\n      } else {\r\n         if (!item.classList.contains('once')) {\r\n            item.classList.remove('show-up')\r\n         }\r\n      }\r\n   })\r\n}\r\n\r\nanimItems.length > 0 ? window.addEventListener('scroll', scrollAnimation) : ''\r\n\n\n//# sourceURL=webpack://FORKIO/./src/js/utilities/scrollAnimation.js?");

/***/ }),

/***/ "./src/js/utilities/utils.js":
/*!***********************************!*\
  !*** ./src/js/utilities/utils.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"typeItHtml\": () => (/* binding */ typeItHtml)\n/* harmony export */ });\n// html-content for typingAnimation.js (TypeIt)\r\nconst typeItHtml = {\r\n   sectionOne: '<i class=\"const\">import <i class=\"attribute\">{ <i class=\"base\">useState</i> } </i> from</i><i class=\"string\">`react`</i> <br><br>',\r\n   sectionTwo:\r\n      '<i class=\"const\">import <i class=\"base\">Button</i> from</i><i class=\"string\"> `./components/Button`</i><br> <i class=\"const\">import</i><i class=\"base\"> Counter </i><i class=\"const\">from</i> <i class=\"string\">`./components/Counter`</i></i> <br><br>',\r\n   sectionThree:\r\n      '<i class=\"const\">const</i><i class=\"base\"> App </i><i class=\"attribute\"> = () => { </i><br><i class=\"padding const\">const </i> <i class=\"attribute\">[count <i class=\"i\">,</i> setCount] =</i> <i class=\"base\">useState</i><i class=\"attribute\">(0)</i><br><br><i class=\"const padding\">const</i> <i class=\"base\">incrementCount</i><i class=\"attribute\"> = () => setCount(count + 1) </i> <br><br>',\r\n   sectionFour:\r\n      '<i class=\"const padding \">return</i><i class=\"attribute\"> ( </i> <br><i class=\"base padding-1\"><i class=\"base\"> <</i>div</i> <i class=\"attribute\">className</i><i class=\"string\"> =\"App\"</i><i class=\"base\">></i><br><i class=\"base padding-2\"><</i><i class=\"component\">Counter</i> <i class=\"attribute\">count</i><i class=\"string\">=</i><i class=\"base\">{<i class=\"attribute\">count</i></i><i class=\"base\">} /></i><br><i class=\"base padding-2\"><<i class=\"component\">Button</i> <i class=\"attribute\">onClick</i><i class=\"string\">=</i>{incrementCount} /></i><br><i class=\"base padding-1\"><i class=\"base\"><</i>div></i><br><i class=\"attribute padding\">)</i><br><i class=\"attribute\">}</i>',\r\n   sectionFive: '<br><br><i class=\"const\">export default <i class=\"base\">App</i></i>',\r\n}\r\n\n\n//# sourceURL=webpack://FORKIO/./src/js/utilities/utils.js?");

/***/ }),

/***/ "./src/js/utilities/validateEmail.js":
/*!*******************************************!*\
  !*** ./src/js/utilities/validateEmail.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"validateEmail\": () => (/* binding */ validateEmail)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./src/js/utilities/constants.js\");\n\r\n\r\n;\r\n\r\nconst validateEmail = () => {\r\n   const btn = document.querySelector('.footer__newsletter--btn')\r\n   const input = document.querySelector('.footer__newsletter--input')\r\n\r\n   const hint = document.querySelector('.footer__newsletter--hint')\r\n   const hintFalse = document.querySelector('.footer__newsletter--hint_false')\r\n   const clientsEmail = []\r\n\r\n   const validateEmail = email => {\r\n      if (email.match(_constants_js__WEBPACK_IMPORTED_MODULE_0__.EMAIL_REGEXP)) {\r\n         hint.classList.add('show_hint')\r\n         clientsEmail.push(email)\r\n\r\n         setTimeout(() => {\r\n            hint.classList.remove('show_hint')\r\n            input.value = ''\r\n         }, 1000)\r\n\r\n      } else {\r\n         hintFalse.classList.add('show_hint')\r\n      }\r\n\r\n      if (email === '') {\r\n         hint.classList.remove('show_hint')\r\n         hintFalse.classList.remove('show_hint')\r\n      }\r\n   }\r\n\r\n   btn.addEventListener('click', () => {\r\n      const email = input.value\r\n      validateEmail(email)\r\n   })\r\n\r\n   input.addEventListener('focus', () => {\r\n      hintFalse.classList.remove('show_hint')\r\n   })\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FORKIO/./src/js/utilities/validateEmail.js?");

/***/ }),

/***/ "./src/js/vendors/_vendorsExports.js":
/*!*******************************************!*\
  !*** ./src/js/vendors/_vendorsExports.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"typingAnimation\": () => (/* reexport safe */ _typingAnimation_js__WEBPACK_IMPORTED_MODULE_0__.typingAnimation)\n/* harmony export */ });\n/* harmony import */ var _typingAnimation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typingAnimation.js */ \"./src/js/vendors/typingAnimation.js\");\n\r\n\n\n//# sourceURL=webpack://FORKIO/./src/js/vendors/_vendorsExports.js?");

/***/ }),

/***/ "./src/js/vendors/typingAnimation.js":
/*!*******************************************!*\
  !*** ./src/js/vendors/typingAnimation.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"typingAnimation\": () => (/* binding */ typingAnimation)\n/* harmony export */ });\n/* harmony import */ var typeit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! typeit */ \"./node_modules/typeit/dist/index.es.js\");\n/* harmony import */ var _utilities_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities/utils.js */ \"./src/js/utilities/utils.js\");\n\r\n;\r\n\r\n\r\n\r\nconst typingAnimation = new typeit__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('.screen__animation', {\r\n   speed: 1,\r\n   waitUntilVisible: true,\r\n})\r\n   .type(_utilities_utils_js__WEBPACK_IMPORTED_MODULE_1__.typeItHtml.sectionOne)\r\n   .pause(170)\r\n   .type(_utilities_utils_js__WEBPACK_IMPORTED_MODULE_1__.typeItHtml.sectionTwo)\r\n   .pause(170)\r\n   .type(_utilities_utils_js__WEBPACK_IMPORTED_MODULE_1__.typeItHtml.sectionThree)\r\n   .pause(170)\r\n   .type(_utilities_utils_js__WEBPACK_IMPORTED_MODULE_1__.typeItHtml.sectionFour)\r\n   .pause(300)\r\n   .type(_utilities_utils_js__WEBPACK_IMPORTED_MODULE_1__.typeItHtml.sectionFive)\r\n\n\n//# sourceURL=webpack://FORKIO/./src/js/vendors/typingAnimation.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/app.js");
/******/ 	
/******/ })()
;